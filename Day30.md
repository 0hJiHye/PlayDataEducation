# Day30

#### 학습목표

1. 테이블 생성을 할 수 있다.
2. 제약규칙과 데이터 무결성에 대해서 구분하고 숙지할 수 있다.
3. 생성된 테이블을 이용해서 속성과 테이블의 관계를 알 수 있다.
4. user_00테이블의 내용을 확인하여 생성된 테이블의 정보를 확인 할 수 있다.




#### 테이블

------

```sql
DESC USER_TABLES; //현재 계정으로 접속하여 생성된 테이블의 정보를 취득

SELECT TABLE_NAME, STATUS, LOGGING, NUM_ROWS
FROM USER_TABLES;

DESC USER_CONSTRAINTS; //테이블에 대한 제약 정보를 취득

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, SEARCH_CONDITION, R_OWNER, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
/*WHERE TABLE_NAME ='NOT_NULL';*/
```



Naming Rule

- 테이블 및 컬럼 이름 -문자로 시작, 30자 이하 영문 대/소문자, 숫자, 특수문자, 한글만 포함(한글 세팅된 곳에서만)
- 중복되는 이름은 사용할 수 없음
- 예약 키워드는 사용할 수 없음



#### 제약조건

------

- 데이터 무결성 : 데이터베이스에 저장되어 있는 데이터가 손상되거나 원래의 의미를 잃지 않고 유지하는 상태 

- 데이터 무결성 제약조건 : 데이터 무결성을 보장하기 위해 오라클에서 지원하는 방법

  |            제약조건             |                             설명                             |  설정 레벨   |
  | :-----------------------------: | :----------------------------------------------------------: | :----------: |
  |            NOT NULL             |            해당 컬럼에 NULL을 포함되지 않도록 함             |     컬럼     |
  |             UNIQUE              |         해당 컬럼 또는 컬럼 조합 값이 유일하도록 함          | 컬럼, 테이블 |
  |           PRIMARY KEY           |             각 행을 유일하게 식별할 수 있도록 함             | 컬럼, 테이블 |
  | REFERENCES TABLE(*column_name*) | 해당 컬럼이 참조하고 있는 테이블의 특정 컬럼 값들과 일치하거나 또는 NULL이 되도록 보장함 | 컬럼, 테이블 |
  |              CHECK              |         해당 컬럼에 특정 조건을 항상 만족시키도록 함         | 컬럼, 테이블 |

- 이름으로 관리 
  - 문자로 시작, 길이는 30자까지 가능
  - 이름을 따로 지정하지 않으면 자동 생성
- 생성 시기
  - 테이블 생성과 동시
  - 테이블을 생성한 후
- 컬럼 레벨 또는 테이블 레벨에서 정의할 수 있다.
  - not null은 '컬럼 레벨'에서만 가능하다.
  - 컬럼 여러개를 조합하는 경우에는 '테이블 레벨' 에서만 가능



##### NOT_NULL

```sql
create table not_null(
id varchar2(10) not null
);

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, SEARCH_CONDITION, R_OWNER, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME ='NOT_NULL';
```



##### UNIQUE

```SQL
CREATE TABLE TABLE_UNIQUE(
id varchar2(10) unique
);

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME ='table_unique';



--2.복합 UNIQUE 테이블 생성
CREATE TABLE TABLE_UNIQUE2(
ID CHAR(3),
SNAME VARCHAR(20),
SCODE CHAR(2),
CONSTRAINT TN2_ID_UN UNIQUE(ID,SNAME));

--제약조건 확인
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, SEARCH_CONDITION, R_OWNER, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME ='TABLE_UNIQUE2';



--3.다중 UNIQUE 테이블 생성
CREATE TABLE TABLE_UNIQUE3(
ID CHAR(3) UNIQUE,
SNAME VARCHAR(20) UNIQUE,
SCODE CHAR(2));

--제약조건 확인
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, SEARCH_CONDITION, R_OWNER, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME ='TABLE_UNIQUE3';


--4.UNIQUE 테이블 생성 
CREATE TABLE TABLE_UNIQUE4(
ID CHAR(3) CONSTRAINT TN4_ID_UN UNIQUE,
SNAME VARCHAR(20) CONSTRAINT TN4_ID_UN UNIQUE,
SCODE CHAR(2));
```

null 값 허용, 단일 값만





##### PRIMARY KEY

UNIQUE+NOT NULL 의미

테이블 당 1개만 생성가능

```
CREATE TABLE TABLE_PK(
ID CHAR(3) PRIMARY KEY,
SNAME VARCHAR2(20));

INSERT INTO TABLE_PK VALUES('100','ORACLE');
INSERT INTO TABLE_PK VALUES('100','IBM');
INSERT INTO TABLE_PK VALUES(NULL,'SUN'); //pk값 null에러


CREATE TABLE TABLE_PK2(
ID CHAR(3),
SNAME VARCHAR2(20),
SCODE CHAR(2),
CONSTRAINT TP2_PK PRIMARY KEY(ID,SNAME));

INSERT INTO TABLE_PK2 VALUES('100','ORACLE','02');
INSERT INTO TABLE_PK2 VALUES('100','ORACLE','01');
```





##### FOREIGN KEY

참조 테이블의 컬럼 값과 일치하거나 NULL 상태를 유지하도록 한다. 

```
CREATE TABLE TABLE_FK(
ID NUMBER,
SNAME VARCHAR(20),
LID NUMBER(2) REFERENCES DEPT(DEPTNO));
```

```
CREATE TABLE MYDEPT(
ID NUMBER PRIMARY KEY,
NO NUMBER UNIQUE);

INSERT INTO MYDEPT VALUES(1,1);
INSERT INTO MYDEPT VALUES(2,2);
INSERT INTO MYDEPT VALUES(3,3);
INSERT INTO MYDEPT VALUES(5,NULL);
INSERT INTO MYDEPT VALUES(6,);
INSERT INTO MYDEPT VALUES(7,7);

CREATE TABLE MY(LID NUMBER REFERENCES MYDEPT);
CREATE TABLE MY02(LID NUMBER REFERENCES MYDEPT(NO));

INSERT INTO MY VALUES(1);
INSERT INTO MY02 VALUES(1);
INSERT INTO MY VALUES(2);
INSERT INTO MY02 VALUES(2);
INSERT INTO MY VALUES(3);
INSERT INTO MY02 VALUES(3);
INSERT INTO MY VALUES(4);
INSERT INTO MY02 VALUES(4);
INSERT INTO MY02 VALUES(5);
INSERT INTO MY VALUES(5);

CREATE TABLE MYDEPT02(
ID NUMBER PRIMARY KEY,
NO NUMBER UNIQUE);

INSERT INTO MYDEPT02 VALUES(1,1);
INSERT INTO MYDEPT02 VALUES(2,2);

CREATE TABLE MY03(LID NUMBER REFERENCES MYDEPT02(NO));
INSERT INTO MY03 VALUES(2);
INSERT INTO MY03 VALUES(3);
```

FOREIGN KEY 제약조건을 생성할 때, 참조 컬럼 값이 삭제되는 경우 FOREIGN KEY 컬럼 값을 어떻게 처리할 지 지정 가능

- ON DELETE SET NULL

  참조 컬럼 값이 삭제될 때, FOREIGN KEY 컬럼 값이 NULL로 변하는 옵션

- ON DELETE CASCADE

  참조 컬럼 값이 삭제될 때, FOREIGN KEY 컬럼 값도 함께 삭제하는 옵션





Q1. EMP의 제약 조건을 확인 한다.

```
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, SEARCH_CONDITION, R_OWNER, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME ='EMP'

PK_EMP  P
FK_DEPTNO  R
BIG5  PK_DEPT
```

Q2. MYTEST라는 테이블을 EMP랑 동일하게 생성 후 제약조건이 추가되어 있는지 확인한다.

```sql
CREATE TABLE MYTEST
AS 
SELECT * FROM EMP;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, SEARCH_CONDITION, R_OWNER, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME ='MYTEST';
//구조만 오기 때문에 제약조건 없음.
```

Q3

```
CREATE TABLE TABLE_FK02(
LID NUMBER REFERENCES DEPT);
->참조되는 대상의 테이블은 반드시 PK만 참조된다.
->PK는 반드시 하나만 존재하기 때문에 테이블명만 명시하고 참조해도 자동으로 PK컬럼을 참조하게 된다.
->만일 참조되는 대상 테이블의 컬럼명을 명시하게 되면 PK, U가 지정돼있어야 한다.
EX)CREATE TABLE TABLE_FK02(
LID NUMBER REFERENCES DEPT(ID));
:DEPT 테이블의 ID는 PRIMARY KEY OR UNIQUE KEY가 지정되어 있다.
*반드시 참조되는 테이블에는 데이터가 존재해야한다.

```





##### check

각 컬럼 값이 만족해야 하는 조건을 지정

```
CREATE TABLE TABLE_CHECK(
EMP_ID CHAR(3) PRIMARY KEY,
SALARY NUMBER CHECK(SALARY>0),
MARRIAGE CHAR(1),
CONSTRAINT CHK_MRG CHECK (MARRIAGE IN ('Y','X')));

INSERT INTO TABLE_CHECK VALUES('100',100,'Y');
INSERT INTO TABLE_CHECK VALUES('100',-100,'Y');

CREATE TABLE TABLE_CHECK2(
ID CHAR(3) PRIMARY KEY,
HIREDATE DATE CHECK(HIREDATE<SYSDATE));

CREATE TABLE TABLE_CHECK3(
EID CHAR(3) PRIMARY KEY,
ENAME VARCHAR2(10) NOT NULL,
SALARY NUMBER,
MARRIAGE CHAR(1),
CHECK(SALARY > 0 AND SALARY < 1000000));


```





서브쿼리를 활용한 테이블 생성 구문

CREATE TABLE table_name [ (column_name )]







```
--1
CREATE TABLE TO_DEPARTMENT(
DEPARTMENT_NO VARCHAR2(10) PRIMARY KEY,
DEPARTMENT_NAME VARCHAR2(20) NOT NULL,
CATEGORY VARCHAR2(20),
OPEN_YN CHAR(1),
CAPACITY NUMBER);

--5
CREATE TABLE TB_STUDENT(
STUDENT_NO VARCHAR2(10),
DEPARTMENT_NO VARCHAR2(10),
STUDENT_NAME VARCHAR2(30) NOT NULL,
STUDENT_SSN VARCHAR2(14),
STUDENT_ADDRESS VARCHAR2(100),
ABSENCE_YN CHAR(1) CHECK (ABSENCE_YN IN('Y','N')),
COACH_PROFESSOR_NO VARCHAR2(10),
CONSTRAINT TB_STUDENT_PK PRIMARY KEY (STUDENT_NO),
CONSTRAINT TB_STUDENT_FK FOREIGN KEY (DEPARTMENT_NO) REFERENCES TO_DEPARTMENT(DEPARTMENT_NO),
CONSTRAINT TB_STUDENT2_FK FOREIGN KEY (COACH_PROFESSOR_NO) REFERENCES TB_PROFESSOR(PROFESSOR_NO));

--2
CREATE TABLE TB_CLASS(
CLASS_NO VARCHAR2(10),
DEPARTMENT_NO VARCHAR2(10) NOT NULL,
PREATTENDING_CLASS_NO VARCHAR2(10),
CLASS_NAME VARCHAR2(30) NOT NULL,
CLASS_TYPE VARCHAR2(10),
CONSTRAINT TB_CLASS_PK PRIMARY KEY(CLASS_NO),
CONSTRAINT TB_CLASS_FK FOREIGN KEY (DEPARTMENT_NO) REFERENCES TO_DEPARTMENT (DEPARTMENT_NO),
CONSTRAINT TB_CLASS_FK2 FOREIGN KEY (PREATTENDING_CLASS_NO) REFERENCES TB_CLASS(CLASS_NO));

--4
CREATE TABLE TB_CLASS_PROFESSOR(
CLASS_NO VARCHAR2(10),
PROFESSOR_NO VARCHAR2(10) ,
CONSTRAINT TB_CLASS_PROFESSOR_PK PRIMARY KEY(CLASS_NO,PROFESSOR_NO),
CONSTRAINT TB_CLASS_PROFESSOR_FK FOREIGN KEY (CLASS_NO) REFERENCES TB_CLASS(CLASS_NO),
CONSTRAINT TB_CLASS_PROFESSOR_FK2 FOREIGN KEY (PROFESSOR_NO) REFERENCES TB_PROFESSOR(PROFESSOR_NO));

--3
CREATE TABLE TB_PROFESSOR(
PROFESSOR_NO VARCHAR2(10),
PROFESSOR_NAME VARCHAR2(30),
PROFESSOR_SSN VARCHAR2(14),
PROFESSOR_ADDRESS VARCHAR(100),
DEPARTMENT_NO VARCHAR(10),
CONSTRAINT TB_PROFESSOR_PK PRIMARY KEY(PROFESSOR_NO),
CONSTRAINT TB_PROFESSOR_FK FOREIGN KEY (DEPARTMENT_NO) REFERENCES TO_DEPARTMENT(DEPARTMENT_NO));

--6
CREATE TABLE TB_GRADE(
TERM_NO VARCHAR2(10),
CLASS_NO VARCHAR2(10),
STUDENT_NO VARCHAR2(10),
POINT NUMBER(3,2),
CONSTRAINT TB_GRADE_PK PRIMARY KEY(TERM_NO,CLASS_NO,STUDENT_NO),
CONSTRAINT TB_GRADE_FK FOREIGN KEY (CLASS_NO) REFERENCES TB_CLASS(CLASS_NO),
CONSTRAINT TB_GRADE_FK2 FOREIGN KEY (STUDENT_NO) REFERENCES TB_STUDENT(STUDENT_NO));

```

CREATE TABLE TO_DEPARTMENT();

